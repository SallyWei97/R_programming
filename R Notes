# Introduction to R programming language and data analysis----------------------
# Creater: Wei Zheng
# This note is created based on a video, Introduction to R programming language 
# and data analysis, on the website of Bilibili (id: 基因学院).

# P1-6    Introduction of R-----------------------------------------------------

getwd()
# 看路径
setwd(dir="")
修改保存路径

df <- read.table("dataname.cvs", sep=",", header = T)
# df将数据文件命名
# read.table()读写Excel数据文件
# sep=","来表示空格用字符

table(df$supp, df$dose)
# table()用于制作新表格，$用于统计总量
# aggregate()测量均值、方差等

# 内置数据集 粉色
# 数据框 表格图案
# 函数 蓝色
# tab键自动补齐（第一个）

# 快捷键
# Ctrl+↑，调出历史记录（可输入条件后再执行，即可查找符合条件的历史记录
# ESC中断当前操作
# Alt+shift+k，调出所有快捷操作


# P7-14   R的安装--------------------------------------------------------------

# - 用 "<-" 赋值给一个局部变量，不建议使用=
# - 用 "<<-" 赋值给一个全局变量
# - "<-"的快捷键：alt + - 

mean()
# mean(1:5) -> 3 求1-5的平均数
# mean(1,2,3,4,5) -> 1 只输出第一个向量（1）的平均数，后面为无效输入
# mean(c(1,2,3,4,5)) -> 3 增加的c()帮助识别一串数字

ls()
# 列出所有变量

ls.str()
# 列出所有变量的详细信息

str()
# 括号里填写变量名，输出变量的信息

rm()
# 清除某个变量

rm(list = ls())
# 消除所有变量

history()
# 唤出历史

# 清空界面快捷键 Ctrl+L


save.image()
# 保存工作空间（图片不会自动保存）

# R拓展包安装
# - 在线
#   通过访问镜像站点
#   拓展包的名字都需要被引号
    install.package()
    # eg. install.package("vcd")
    install.packages()
    # eg. install.packages(c("a", "b", "c"))
# - 离线（源代码）
#   镜像站点下载源代码
#   需要注意包之间的依赖关系（通常推荐在线安装）

require()
# 加载包（eg. require(vcd)）
library()
# 加载包
# library和require都可以载入包，但二者存在区别。
# 一个函数中，如果一个包不存在，执行到library将会停止执行，require则会继续执行

help(package="")
# 查询该包的指南(eg. help(package="vcd"))
library(help="")
# 查询包的基础信息，如数据集(eg. library(help=""))
# eg. Baseball (vcd自带数据集）

detach() # eg. detach("package:vcd")
# 从内存内移除，重新require即可使用
remove.packages() # eg. remove.packages("vcd")
# 彻底删除包

installed.packages()
# 可用于拓展包移植，
# eg. 
Rpack <- installed.packages()[,1]
# 创建变量Rpack，为当前所有已安装包的名称（第一列）
save(Rpack,file="Rpack.Rdata")
# 保存变量Rpack
load("C:/Users/three/Documents/Rpack.Rdata")
# 加载该变量（需要移植的新电脑）
Rpack
# 查看该变量（需要移植的新电脑）
for (x in Rpack) install.packages(x)
# 使用循环来安装Rpack中所有包（需要移植的新电脑）

# ?函数名（一个问号查函数）eg. 
?mean
# example（）查看函数的example eg.
example(mean)
# vignette() 查看包的说明(部分包没有该格式的intro） eg.
vignette("xts")
# ??函数名（两个问好查拓展包）eg. ??heatmap

apropos()
# 查询括号内的关键字 eg.
apprpos("sum",mod="function")
# 查询关键字为sum的函数

RsiteSearch()
# 官网查询关键字
# 可使用rseek.org网站，需要vpn

# 数据通常行是观测值，列是变量值

# P15 内置数据集 --------------------------------------------------------------

# 内置数据集都存在datasets包
data()
#  输出所有包含的数据集
rivers
eg. 内置数据集-北美河流长度
data("")
#  输出选定数据集 eg. data("rivers")

# 网盘有数据集整理
class()
# 查看数据集的类型(向量、因子、矩阵等

heatmap()
# 绘制数据集的热力图 eg. heatmap(volcano)

data(package=.packages(all.available=TRUE))
# 查找所有可用数据集

data.frame()
# 制作数据框

data(database,package="程序包"）
# 只加载拓展包里面的数据集，忽略包

# P16-26  编程基础概念---------------------------------------

# 数据类型
# 数值，字符串，逻辑型（布尔），日期型

# 对象
# eg. 常量，数据结构，函数，图形

# 数据结构
# eg. 向量，标量；矩阵；数组；列表；数据框；因子；时间序列

# 1.1 向量 vector---------------------------------------
# 存储数值型字符型等数据的一维数组
# 用函数c()来创建向量（数组）eg.
x <- c(1,2,20,21,22,31,24,44,25,32,27)
y <- c("one","two")
z <- c(TRUE,F,T,F)
# !!字符串必须＋“”
# !!逻辑型必须all大写
c(1:100)
# 1-100等差数列
seq (from=1,to=100,by=4)
seq (from=1,to=100,length.out=8)
# by为等差数列的差，length.out为等差数列个数
rep(x,5)
rep(x,each=5，times=5)
# 重复函数，x可为标量、向量，each是单个重复次数，times是总体重复次数
a <- c(1,2,"three")
# 1,2被转化为字符串
model()
# 查看向量的类型
# ！！R是向量化编程，优势是避免使用循环
> x <- c(1,2)
> y <- c(3,4)
> x*3+y
[1]  6 10
> x[x<2]
[1] 1
> rep(x,c(2,3))
[1] 1 1 2 2 2


# 1.2 向量索引 ---------------------------------------
# 正负整数索引；逻辑向量索引；名称索引

# 正负整数索引
> x <- c(1:100)
> length(x)
[1] 100
> x[10]
[1] 10
> x[-66] # 不显示第66个数
 [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17
[18]  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34
[35]  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51
[52]  52  53  54  55  56  57  58  59  60  61  62  63  64  65  67  68  69
[69]  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86
[86]  87  88  89  90  91  92  93  94  95  96  97  98  99 100
> x[c(-10:-90)]
 [1]   1   2   3   4   5   6   7   8   9  91  92  93  94  95  96  97  98
[18]  99 100

# 逻辑索引
> y <- c(1:10)
> y[c(T,F,F,T,T)]
[1]  1  4  5  6  9 10
> y[c(T,F,F,T,T,F,F,T,T,F,F,T,T)]
[1]  1  4  5  8  9 NA NA #NA缺失值
> y[y>7]
[1]  8  9 10
> y[y>6 & y<9]
[1] 7 8
> z <- c("one","two","three","four","five")
> "one" %in% z #判断字符串“one”是否是z的元素，
[1] TRUE
> z[z %in% c("one","five")] #相当于 y[c(T,F,F,F,T)]
[1] "one"  "five"

# 名称索引
> names(y) <- c("one","two","three","four","five","six","seven","eight","nine","ten")
> y
  one   two three  four  five   six seven eight  nine   ten 
    1     2     3     4     5     6     7     8     9    10 
> y["two"]
two 
  2
# 通常用于数组等情景，第一行相当于Excel的列名  
  
# 向量修改-------------------------------------------------------------
> x[101] <- 1000
> x
  [1]    1    2    3    4    5    6    7    8    9   10   11   12   13
 [14]   14   15   16   17   18   19   20   21   22   23   24   25   26
 [27]   27   28   29   30   31   32   33   34   35   36   37   38   39
 [40]   40   41   42   43   44   45   46   47   48   49   50   51   52
 [53]   53   54   55   56   57   58   59   60   61   62   63   64   65
 [66]   66   67   68   69   70   71   72   73   74   75   76   77   78
 [79]   79   80   81   82   83   84   85   86   87   88   89   90   91
 [92]   92   93   94   95   96   97   98   99  100 1000
# 赋值单个向量

> b <- 1:3
> b[c(4:10)] <- c(1,1,2,2,3,3,4)
> b
 [1] 1 2 3 1 1 2 2 3 3 4
# 批量赋值
> b[13] <- 11
> b
 [1]  1  2  3  1  1  2  2  3  3  4 NA NA 11
# 中间为缺失值

> append(x = b,values = 99,after = 5)
 [1]  1  2  3  1  1 99  2  2  3  3  4 NA NA 11
# 插入向量，tab键调出函数参数

rm()
# 删除整个向量
> y <- y[-c(3:5)]
> y
  one   two   six seven eight  nine   ten 
    1     2     6     7     8     9    10 
# 删除某些向量

> y["six"] <- 99
> y
  one   two   six seven eight  nine   ten 
    1     2    99     7     8     9    10 
# 修改某个向量值

# 向量计算------------------------------------------------------------
1.
> x <- 1:5
> x <- x*2
> x
[1]  2  4  6  8 10
> y <- seq(1,20,length.out =5)
> x*y
[1]   2  23  63 122 200
> x**y # 幂运算
[1] 2.000000e+00 2.896309e+03 1.481113e+08 5.917282e+13 1.000000e+20
> y%%x # 求余
[1] 1.00 1.75 4.50 7.25 0.00
> y%/%x # 整除
[1] 0 1 1 1 2
> z <- 1:3
> x+z
[1]  3  6  9  9 12
Warning message: # 长向量个数不是短向量的整数倍
In x + z : longer object length is not a multiple of shorter object length
# 向量的加减乘除

2.
> c(1:3) %in% x
[1] FALSE  TRUE FALSE
# 包含运算符

3.
> x==y
[1] FALSE FALSE FALSE FALSE FALSE
# 等于判断符

4.
> a <- -5:5
> abs(a)
 [1] 5 4 3 2 1 0 1 2 3 4 5
# 取绝对值
> sqrt(a)
 [1]      NaN      NaN      NaN      NaN      NaN 0.000000 1.000000
 [8] 1.414214 1.732051 2.000000 2.236068
# 计算平方根
> log(x = a,base = 2)
 [1]      NaN      NaN      NaN      NaN      NaN     -Inf 0.000000
 [8] 1.000000 1.584963 2.000000 2.321928
# 计算对数
> exp(a)
 [1] 6.737947e-03 1.831564e-02 4.978707e-02 1.353353e-01 3.678794e-01
 [6] 1.000000e+00 2.718282e+00 7.389056e+00 2.008554e+01 5.459815e+01
[11] 1.484132e+02
# 以e为底的指数函数
> ceiling(c(1.22,2.33))
[1] 2 3
# 向上取整
> floor(c(1.22,2.33))
[1] 1 2
# 向下取整
> trunc(c(1.22,2.33))
[1] 1 2
# 去除小数点
> round(c(1.21,2.88,2.18),digits = 1)
[1] 1.2 2.9 2.2
> signif(c(1.21,2.88,2.18),digits=1)
[1] 1 3 2
# 四舍五入 round：digits为小数点后几位。

5.
sin()
cos()
...
# 三角函数计算

6. 统计函数
> vec <- 1:100
> sum(vec)
[1] 5050
> max(vec)
[1] 100
> min(vec)
[1] 1
> range(vec) # 最大值&最小值
[1]   1 100
> mean(vec)
[1] 50.5
> var(vec) # 方差
[1] 841.6667
> sd(vec) # 标准差
[1] 29.01149
> prod(vec) #连乘
[1] 9.332622e+157
> median(vec)
[1] 50.5
> quantile(vec) # 分位数
    0%    25%    50%    75%   100% 
  1.00  25.75  50.50  75.25 100.00 
> quantile(vec,c(0.1,0.8))
 10%  80% 
10.9 80.2 

7.查找向量索引值
> t <- c(1,3,5,7,9,11,13)
> which.max(t)
[1] 7
> which(t==7)
[1] 4
> which(t<mean(t))
[1] 1 2 3
> t[which(t<10)] # 先输出符合条件的索引值，再按索引值输出向量
[1] 1 3 5 7 9

# 2 矩阵 --------------------------------------------------

1.构建矩阵
> m <- matrix(1:30,5,6) # 5是nrow行数，6是ncol列数
> m
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    6   11   16   21   26
[2,]    2    7   12   17   22   27
[3,]    3    8   13   18   23   28
[4,]    4    9   14   19   24   29
[5,]    5   10   15   20   25   30
# 行列数要与向量总数匹配
>  m <- matrix(1:30,5,byrow = T) # 按行分配
> m
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    2    3    4    5    6
[2,]    7    8    9   10   11   12
[3,]   13   14   15   16   17   18
[4,]   19   20   21   22   23   24
[5,]   25   26   27   28   29   30
> m <- matrix(1:30,5,byrow = F)
> m
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    6   11   16   21   26
[2,]    2    7   12   17   22   27
[3,]    3    8   13   18   23   28
[4,]    4    9   14   19   24   29
[5,]    5   10   15   20   25   30
# 按列分配

